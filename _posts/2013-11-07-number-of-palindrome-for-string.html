---
layout: default
title: 一点回文
---

<div id="headAera">
	<h>{{ page.title }}</h3>
</div>


<div id="mainContent">
	<p><span>C</span>areercup,Amazon:Find number of palindromes in a string.</p>
	<p><a href="http://www.careercup.com/question?id=5442107225407488">这</a>就是本文的导火线，一开始没太明白起意思，评论中的代码给了我启发，找出字符串中回文串的数目，这些代码也当然就给出了解题思路。大致读了一下回复的代码，基本都是一个思路：截取子串进行回文判断并计数，最终得到结果。这是最直接的路子，细细的想想，一般都能想到，<a href="">实现</a>起来也不算难</p>
	<p>
		<ul>
			<li>实现一个回文判断的方法；</li>
			<li>切割子串塞进上面的方法里检验－计数。</li>
		</ul>
	</p>
	<p>简单剖析一下这个算法，字符串的长度决定着子串的数目，子串的数目决定着循环检验的次数，即决定着算法的时间复杂度。稍作分析，可以知道长度为n的字符串可以切割出“（1 + n）＊n ／ 2”个子串。所以其复杂度至少应为O(n^2)，再结合调用回文判断的开销，复杂度还会再高一点。</p>
	<p>当然，我不能满足于以上述算法解决这个问题。当问题得到解决之后，要思考能不能将问题解决的更漂亮。于是我苦思冥想，终于得到了一个不一样的思路，这会是一个更漂亮的算法吗？当然希望是。且先看<a href="">真容</a>吧</p>
	<p>该算法是从回文串是对称这一特点入手。
		<ul>
			<li>随机选择字符串中的一个字符，以其为中心（或者说对称轴）对其两边的字符进行检验，如果匹配则找到一个回文串，并可以继续向两边扩张；如果不匹配呢，该点就可以抛弃了。</li>
			<li>随机选择字符串中的两个字符，同上。</li>
 		</ul>
	   这就是<a href="">这个算法</a>。
	</p>
	<p>那么，我这个(我这里的意思是我并没有参考谁的思路而想到这个算法)会比前面的好吗？最直接的就是请他们自己来证明，跑起来，数据说话。拭目以待吧。</p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
	<p></p>
</div>
